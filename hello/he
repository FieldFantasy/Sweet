#include "reg52.h"

typedef unsigned char u8;
typedef unsigned int u16;

// 定义独立按键控制脚
sbit KEY1 = P3 ^ 1;
sbit KEY2 = P3 ^ 0;
sbit KEY3 = P3 ^ 2;
sbit KEY4 = P3 ^ 3;

// 定义 LED 控制脚
sbit LED1 = P2 ^ 0;
sbit LED2 = P2 ^ 1;
sbit LED3 = P2 ^ 2;
sbit LED4 = P2 ^ 3;

// 使用宏定义独立按键按下的键值
#define KEY1_PRESS 1
#define KEY2_PRESS 2
#define KEY3_PRESS 3
#define KEY4_PRESS 4
#define KEY_UNPRESS 0

// 延时函数
void delay_10us(u16 ten_us) {
    while (ten_us--);
}

// 检测独立按键是否按下，按下则返回对应键值，当按钮被按下时，对应的 KEY 的值会变为0。
//在8051系列的单片机中（包括reg52.h中定义的常见单片机），引脚默认状态为高电平（逻辑1）。当按键按下时，按键接地，引脚的电平变为低电平（逻辑0）
u8 key_scan(u8 mode) {
    static u8 key = 1;
    if (mode) key = 1; // 进行连续扫描按键操作，如果说mode为0，不连续，mode为1连续

    if (key == 1 && (KEY1 == 0 || KEY2 == 0 || KEY3 == 0 || KEY4 == 0)) {
        delay_10us(1000); // 消抖
        key = 0;
        if (KEY1 == 0) {
            return KEY1_PRESS;
        } else if (KEY2 == 0) {
            return KEY2_PRESS;
        } else if (KEY3 == 0) {
            return KEY3_PRESS;
        } else if (KEY4 == 0) {
            return KEY4_PRESS;
        }
    } else if (KEY1 == 1 && KEY2 == 1 && KEY3 == 1 && KEY4 == 1) {//这一步是当进行完第一次的按键按下时，将key的值重置为1
        key = 1;
    }
    return KEY_UNPRESS;
}

void main() {
    u8 key = 0;
    while (1) {
        key = key_scan(0); // 单次按键扫描操作
        if (key == KEY1_PRESS) { // 检测按键是否按下
            LED1 = ~LED1;
        }else if(key == KEY2_PRESS){
		 LED2 = ~LED2;
		}else if(key == KEY3_PRESS){
		 LED3 = ~LED3;
		}else if(key == KEY4_PRESS){
		 LED4 = ~LED4;
		}
    }
}
//也就是说48--50行的代码主要是针对单次按动的每当进行单次按动后，由于key是静态类型（static），所以其值不会变，当检测到KEY的所有键位的电平都为高电平时（为1）就会进行这个操作，然后将key值重置，以为下次按动做准备
